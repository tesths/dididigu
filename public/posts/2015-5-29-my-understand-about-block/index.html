<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Block 我所理解的回调 | PaperMod</title>
<meta name="keywords" content="">
<meta name="description" content="FOR CM AND PLUSUB 废话 开发iOS距离一年还有四个月。block的文章看了很多。也在项目中使用了，但是使用率很低，仅限于最最简单的界面传值。
我最近处于一个深度学习和补作业做实验的阶段(重点是补作业和做实验)，而且经历了两个项目现在对于OC的理解又更进了一步。于是抽时间把之前下载的关于block的视频又翻出来看了一下。有一些感受写出来，以便CM和PLUSUB以后的iOSer可以很快的学习到关于block的使用。以后这样的文章都会在标题加一个FOR CM AND PLUSUB。
概述 block就是闭包，可以用来回调。
再简单一点，指向函数的指针。
我现在只会简单的使用block，下午写了个demo利用block封装了afnetworking然后在另一个界面调用afnetworking的请求。当然不复杂。
上代码吧，不然再废话都解释不清楚什么是block。
part1 block的简单定义 我现在定义一个简单的block。 {% highlight objc %} void (^myBlock)(NSString *str);//1 myBlock = ^(NSString *str) { NSLog(@&quot;&mdash;%@&quot;, str);//2 }; myBlock(@&ldquo;11111&rdquo;);//3 // Outputs:&mdash;11111 {% endhighlight %} 可以这么理解，我定义了一个返回值为void类型的block。void后面跟了一个函数，但是这个函数函数名是以^开头的，需要用括号包起来，参数也需要用括号包起来。参数可以是一个int类型，可以是一个NSString类型，还可以是一个函数！可以是多个参数还可以是一个函数。当然如果是int类型的block就需要return一个返回值了。
然后我们开始对这个void类型的函数进行定义。就是令它等于一个“^&#43;参数”然后里面像定义一个函数一样就行了。 在调用这个block的时候就直接就myBlock加参数就可以了。
我们可以打断点来看一下整个block的执行顺序。我在代码后面加了标示。
执行顺序是1 3 2，可以看到myBlock没有按照程序执行的顺序来调用而是在调用之后执行了2的代码。这个例子可能不那么明显，但是可以开始初步理解回调。
part2 传参block 下面把难度加大一点，我们把block当参数传。然后看一个block的例子。 首先来回顾一个c语言里伟大的typedef，我们开头会利用typedef定义一个block。如果不利用typedef定义一个block，那么函数传参的时候会写很多代码。一会我会详述。 {% highlight objc %} #import &ldquo;ViewController.h&rdquo; typedef void (^MyBlock)(NSString *str);//typedef定义一个block
@interface ViewController () @end
@implementation ViewController
(void)viewDidLoad { [super viewDidLoad]; MyBlock tblock = ^(NSString *str) { NSLog(@&quot;&mdash;&ndash;%@&quot;, str);//1 }; [self testBlock:tblock];//2 } (void)testBlock:(MyBlock)mBlock //如果开始没有用typedef定义的话，此处的函数变为- (void)testBlock:(void(^)(NSString *str))myblock //简单的说格式就是 “返回值 &#43; (^) &#43; 参数 &#43; 名字” { mBlock(@&ldquo;1111&rdquo;);//3 } // Outputs:&mdash;&ndash;1111 {% endhighlight %} 在上面的代码中，我们写了一个testBlock的函数，将我们的tblock作为参数传到了testBlock函数里面，然后再testBlock里用mBlock调用了我们所写的MyBlock这个函数。">
<meta name="author" content="Me">
<link rel="canonical" href="http://localhost:1313/posts/2015-5-29-my-understand-about-block/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/2015-5-29-my-understand-about-block/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
  

<meta property="og:title" content="Block 我所理解的回调" />
<meta property="og:description" content="FOR CM AND PLUSUB 废话 开发iOS距离一年还有四个月。block的文章看了很多。也在项目中使用了，但是使用率很低，仅限于最最简单的界面传值。
我最近处于一个深度学习和补作业做实验的阶段(重点是补作业和做实验)，而且经历了两个项目现在对于OC的理解又更进了一步。于是抽时间把之前下载的关于block的视频又翻出来看了一下。有一些感受写出来，以便CM和PLUSUB以后的iOSer可以很快的学习到关于block的使用。以后这样的文章都会在标题加一个FOR CM AND PLUSUB。
概述 block就是闭包，可以用来回调。
再简单一点，指向函数的指针。
我现在只会简单的使用block，下午写了个demo利用block封装了afnetworking然后在另一个界面调用afnetworking的请求。当然不复杂。
上代码吧，不然再废话都解释不清楚什么是block。
part1 block的简单定义 我现在定义一个简单的block。 {% highlight objc %} void (^myBlock)(NSString *str);//1 myBlock = ^(NSString *str) { NSLog(@&quot;&mdash;%@&quot;, str);//2 }; myBlock(@&ldquo;11111&rdquo;);//3 // Outputs:&mdash;11111 {% endhighlight %} 可以这么理解，我定义了一个返回值为void类型的block。void后面跟了一个函数，但是这个函数函数名是以^开头的，需要用括号包起来，参数也需要用括号包起来。参数可以是一个int类型，可以是一个NSString类型，还可以是一个函数！可以是多个参数还可以是一个函数。当然如果是int类型的block就需要return一个返回值了。
然后我们开始对这个void类型的函数进行定义。就是令它等于一个“^&#43;参数”然后里面像定义一个函数一样就行了。 在调用这个block的时候就直接就myBlock加参数就可以了。
我们可以打断点来看一下整个block的执行顺序。我在代码后面加了标示。
执行顺序是1 3 2，可以看到myBlock没有按照程序执行的顺序来调用而是在调用之后执行了2的代码。这个例子可能不那么明显，但是可以开始初步理解回调。
part2 传参block 下面把难度加大一点，我们把block当参数传。然后看一个block的例子。 首先来回顾一个c语言里伟大的typedef，我们开头会利用typedef定义一个block。如果不利用typedef定义一个block，那么函数传参的时候会写很多代码。一会我会详述。 {% highlight objc %} #import &ldquo;ViewController.h&rdquo; typedef void (^MyBlock)(NSString *str);//typedef定义一个block
@interface ViewController () @end
@implementation ViewController
(void)viewDidLoad { [super viewDidLoad]; MyBlock tblock = ^(NSString *str) { NSLog(@&quot;&mdash;&ndash;%@&quot;, str);//1 }; [self testBlock:tblock];//2 } (void)testBlock:(MyBlock)mBlock //如果开始没有用typedef定义的话，此处的函数变为- (void)testBlock:(void(^)(NSString *str))myblock //简单的说格式就是 “返回值 &#43; (^) &#43; 参数 &#43; 名字” { mBlock(@&ldquo;1111&rdquo;);//3 } // Outputs:&mdash;&ndash;1111 {% endhighlight %} 在上面的代码中，我们写了一个testBlock的函数，将我们的tblock作为参数传到了testBlock函数里面，然后再testBlock里用mBlock调用了我们所写的MyBlock这个函数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/2015-5-29-my-understand-about-block/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-05-29T00:00:00+00:00" />
<meta property="article:modified_time" content="2015-05-29T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="Block 我所理解的回调"/>
<meta name="twitter:description" content="FOR CM AND PLUSUB 废话 开发iOS距离一年还有四个月。block的文章看了很多。也在项目中使用了，但是使用率很低，仅限于最最简单的界面传值。
我最近处于一个深度学习和补作业做实验的阶段(重点是补作业和做实验)，而且经历了两个项目现在对于OC的理解又更进了一步。于是抽时间把之前下载的关于block的视频又翻出来看了一下。有一些感受写出来，以便CM和PLUSUB以后的iOSer可以很快的学习到关于block的使用。以后这样的文章都会在标题加一个FOR CM AND PLUSUB。
概述 block就是闭包，可以用来回调。
再简单一点，指向函数的指针。
我现在只会简单的使用block，下午写了个demo利用block封装了afnetworking然后在另一个界面调用afnetworking的请求。当然不复杂。
上代码吧，不然再废话都解释不清楚什么是block。
part1 block的简单定义 我现在定义一个简单的block。 {% highlight objc %} void (^myBlock)(NSString *str);//1 myBlock = ^(NSString *str) { NSLog(@&quot;&mdash;%@&quot;, str);//2 }; myBlock(@&ldquo;11111&rdquo;);//3 // Outputs:&mdash;11111 {% endhighlight %} 可以这么理解，我定义了一个返回值为void类型的block。void后面跟了一个函数，但是这个函数函数名是以^开头的，需要用括号包起来，参数也需要用括号包起来。参数可以是一个int类型，可以是一个NSString类型，还可以是一个函数！可以是多个参数还可以是一个函数。当然如果是int类型的block就需要return一个返回值了。
然后我们开始对这个void类型的函数进行定义。就是令它等于一个“^&#43;参数”然后里面像定义一个函数一样就行了。 在调用这个block的时候就直接就myBlock加参数就可以了。
我们可以打断点来看一下整个block的执行顺序。我在代码后面加了标示。
执行顺序是1 3 2，可以看到myBlock没有按照程序执行的顺序来调用而是在调用之后执行了2的代码。这个例子可能不那么明显，但是可以开始初步理解回调。
part2 传参block 下面把难度加大一点，我们把block当参数传。然后看一个block的例子。 首先来回顾一个c语言里伟大的typedef，我们开头会利用typedef定义一个block。如果不利用typedef定义一个block，那么函数传参的时候会写很多代码。一会我会详述。 {% highlight objc %} #import &ldquo;ViewController.h&rdquo; typedef void (^MyBlock)(NSString *str);//typedef定义一个block
@interface ViewController () @end
@implementation ViewController
(void)viewDidLoad { [super viewDidLoad]; MyBlock tblock = ^(NSString *str) { NSLog(@&quot;&mdash;&ndash;%@&quot;, str);//1 }; [self testBlock:tblock];//2 } (void)testBlock:(MyBlock)mBlock //如果开始没有用typedef定义的话，此处的函数变为- (void)testBlock:(void(^)(NSString *str))myblock //简单的说格式就是 “返回值 &#43; (^) &#43; 参数 &#43; 名字” { mBlock(@&ldquo;1111&rdquo;);//3 } // Outputs:&mdash;&ndash;1111 {% endhighlight %} 在上面的代码中，我们写了一个testBlock的函数，将我们的tblock作为参数传到了testBlock函数里面，然后再testBlock里用mBlock调用了我们所写的MyBlock这个函数。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Block 我所理解的回调",
      "item": "http://localhost:1313/posts/2015-5-29-my-understand-about-block/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Block 我所理解的回调",
  "name": "Block 我所理解的回调",
  "description": "FOR CM AND PLUSUB 废话 开发iOS距离一年还有四个月。block的文章看了很多。也在项目中使用了，但是使用率很低，仅限于最最简单的界面传值。\n我最近处于一个深度学习和补作业做实验的阶段(重点是补作业和做实验)，而且经历了两个项目现在对于OC的理解又更进了一步。于是抽时间把之前下载的关于block的视频又翻出来看了一下。有一些感受写出来，以便CM和PLUSUB以后的iOSer可以很快的学习到关于block的使用。以后这样的文章都会在标题加一个FOR CM AND PLUSUB。\n概述 block就是闭包，可以用来回调。\n再简单一点，指向函数的指针。\n我现在只会简单的使用block，下午写了个demo利用block封装了afnetworking然后在另一个界面调用afnetworking的请求。当然不复杂。\n上代码吧，不然再废话都解释不清楚什么是block。\npart1 block的简单定义 我现在定义一个简单的block。 {% highlight objc %} void (^myBlock)(NSString *str);//1 myBlock = ^(NSString *str) { NSLog(@\u0026quot;\u0026mdash;%@\u0026quot;, str);//2 }; myBlock(@\u0026ldquo;11111\u0026rdquo;);//3 // Outputs:\u0026mdash;11111 {% endhighlight %} 可以这么理解，我定义了一个返回值为void类型的block。void后面跟了一个函数，但是这个函数函数名是以^开头的，需要用括号包起来，参数也需要用括号包起来。参数可以是一个int类型，可以是一个NSString类型，还可以是一个函数！可以是多个参数还可以是一个函数。当然如果是int类型的block就需要return一个返回值了。\n然后我们开始对这个void类型的函数进行定义。就是令它等于一个“^+参数”然后里面像定义一个函数一样就行了。 在调用这个block的时候就直接就myBlock加参数就可以了。\n我们可以打断点来看一下整个block的执行顺序。我在代码后面加了标示。\n执行顺序是1 3 2，可以看到myBlock没有按照程序执行的顺序来调用而是在调用之后执行了2的代码。这个例子可能不那么明显，但是可以开始初步理解回调。\npart2 传参block 下面把难度加大一点，我们把block当参数传。然后看一个block的例子。 首先来回顾一个c语言里伟大的typedef，我们开头会利用typedef定义一个block。如果不利用typedef定义一个block，那么函数传参的时候会写很多代码。一会我会详述。 {% highlight objc %} #import \u0026ldquo;ViewController.h\u0026rdquo; typedef void (^MyBlock)(NSString *str);//typedef定义一个block\n@interface ViewController () @end\n@implementation ViewController\n(void)viewDidLoad { [super viewDidLoad]; MyBlock tblock = ^(NSString *str) { NSLog(@\u0026quot;\u0026mdash;\u0026ndash;%@\u0026quot;, str);//1 }; [self testBlock:tblock];//2 } (void)testBlock:(MyBlock)mBlock //如果开始没有用typedef定义的话，此处的函数变为- (void)testBlock:(void(^)(NSString *str))myblock //简单的说格式就是 “返回值 + (^) + 参数 + 名字” { mBlock(@\u0026ldquo;1111\u0026rdquo;);//3 } // Outputs:\u0026mdash;\u0026ndash;1111 {% endhighlight %} 在上面的代码中，我们写了一个testBlock的函数，将我们的tblock作为参数传到了testBlock函数里面，然后再testBlock里用mBlock调用了我们所写的MyBlock这个函数。",
  "keywords": [
    
  ],
  "articleBody": "FOR CM AND PLUSUB 废话 开发iOS距离一年还有四个月。block的文章看了很多。也在项目中使用了，但是使用率很低，仅限于最最简单的界面传值。\n我最近处于一个深度学习和补作业做实验的阶段(重点是补作业和做实验)，而且经历了两个项目现在对于OC的理解又更进了一步。于是抽时间把之前下载的关于block的视频又翻出来看了一下。有一些感受写出来，以便CM和PLUSUB以后的iOSer可以很快的学习到关于block的使用。以后这样的文章都会在标题加一个FOR CM AND PLUSUB。\n概述 block就是闭包，可以用来回调。\n再简单一点，指向函数的指针。\n我现在只会简单的使用block，下午写了个demo利用block封装了afnetworking然后在另一个界面调用afnetworking的请求。当然不复杂。\n上代码吧，不然再废话都解释不清楚什么是block。\npart1 block的简单定义 我现在定义一个简单的block。 {% highlight objc %} void (^myBlock)(NSString *str);//1 myBlock = ^(NSString *str) { NSLog(@\"—%@\", str);//2 }; myBlock(@“11111”);//3 // Outputs:—11111 {% endhighlight %} 可以这么理解，我定义了一个返回值为void类型的block。void后面跟了一个函数，但是这个函数函数名是以^开头的，需要用括号包起来，参数也需要用括号包起来。参数可以是一个int类型，可以是一个NSString类型，还可以是一个函数！可以是多个参数还可以是一个函数。当然如果是int类型的block就需要return一个返回值了。\n然后我们开始对这个void类型的函数进行定义。就是令它等于一个“^+参数”然后里面像定义一个函数一样就行了。 在调用这个block的时候就直接就myBlock加参数就可以了。\n我们可以打断点来看一下整个block的执行顺序。我在代码后面加了标示。\n执行顺序是1 3 2，可以看到myBlock没有按照程序执行的顺序来调用而是在调用之后执行了2的代码。这个例子可能不那么明显，但是可以开始初步理解回调。\npart2 传参block 下面把难度加大一点，我们把block当参数传。然后看一个block的例子。 首先来回顾一个c语言里伟大的typedef，我们开头会利用typedef定义一个block。如果不利用typedef定义一个block，那么函数传参的时候会写很多代码。一会我会详述。 {% highlight objc %} #import “ViewController.h” typedef void (^MyBlock)(NSString *str);//typedef定义一个block\n@interface ViewController () @end\n@implementation ViewController\n(void)viewDidLoad { [super viewDidLoad]; MyBlock tblock = ^(NSString *str) { NSLog(@\"—–%@\", str);//1 }; [self testBlock:tblock];//2 } (void)testBlock:(MyBlock)mBlock //如果开始没有用typedef定义的话，此处的函数变为- (void)testBlock:(void(^)(NSString *str))myblock //简单的说格式就是 “返回值 + (^) + 参数 + 名字” { mBlock(@“1111”);//3 } // Outputs:—–1111 {% endhighlight %} 在上面的代码中，我们写了一个testBlock的函数，将我们的tblock作为参数传到了testBlock函数里面，然后再testBlock里用mBlock调用了我们所写的MyBlock这个函数。\n打断点看一下整体的运行流程，2 3 1。这里可以更加明显理解“回调”的含义。\npart3 点击button触发block 经历了上面两个part基本上应该对block有个简单的理解。下面再加一点难度，用按钮触发一个回调来改变按钮的颜色。\n不多解释，直接上代码。 {% highlight objc %} #import “ViewController.h” typedef void (^MyBlock)(UIColor *color); @interface ViewController () @property (nonatomic, strong) UIButton *testbtn; @end\n@implementation ViewController\n(void)viewDidLoad { [super viewDidLoad]; self.testbtn = [UIButton buttonWithType:UIButtonTypeSystem]; self.testbtn.frame = CGRectMake(0, 0, 200, 40); self.testbtn.backgroundColor = [UIColor greenColor]; [self.view addSubview:self.testbtn]; [self.testbtn addTarget:self action:@selector(testfunc) forControlEvents:UIControlEventTouchUpInside]; } (void)testfunc { MyBlock myblock = ^(UIColor *color) { self.testbtn.backgroundColor = color; }; [self testBlock:myblock]; } (void)testBlock:(MyBlock)myBlock { UIColor *color = [UIColor redColor]; myBlock(color); } {% endhighlight %} part4 利用回调分离afnetwork的请求 直接上代码了。\nTestNetworkViewController是afnetwork使用的地方。 TestViewController是我们需要调用网络请求的地方。 SearchModel是一个model，我用来解析数据的。 {% highlight objc %} // TestNetworkViewController.h #import #import “SearchModel.h” typedef void (^GetModel)(SearchModel *model); @interface TestNetworkViewController : UIViewController\n(void)getUrl:(GetModel)getmodel; @end //TestNetworkViewController.m #import “TestNetworkViewController.h” @interface TestNetworkViewController () @end @implementation TestNetworkViewController\n(void)viewDidLoad { [super viewDidLoad]; } (void)getUrl:(GetModel)getmodel { AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; [manager GET:@“http://xxx.xx.xxx.xx:xxxx/app/search_haosou” parameters:@{@“keyword”:@“android”} success:^(AFHTTPRequestOperation *operation, id responseObject) { NSLog(@“JSON: %@”, responseObject); SearchModel *service = [MTLJSONAdapter modelOfClass:SearchModel.class fromJSONDictionary:responseObject error:nil]; getmodel(service); } failure:^(AFHTTPRequestOperation *operation, NSError *error) { NSLog(@“Error: %@”, error); }]; } @end // TestViewController.h #import #import “SearchModel.h” @interface TestViewController : UIViewController @end\n#import “TestViewController.h” #import “TestNetworkViewController.h” #import “SearchModel.h” @interface TestViewController () @property (nonatomic, strong) SearchModel *test; @end\n@implementation TestViewController\n(void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. UIButton *testBtn = [UIButton buttonWithType:UIButtonTypeSystem]; [testBtn setTitle:@“test” forState:UIControlStateNormal]; [testBtn setTitleColor:[UIColor redColor] forState:UIControlStateNormal]; testBtn.frame = CGRectMake(0, 100, 200, 40); [testBtn addTarget:self action:@selector(getUrl) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:testBtn]; self.view.backgroundColor = [UIColor whiteColor]; } (void)getUrl { [TestNetworkViewController getUrl:^(SearchModel *model) { self.test = model; NSLog(@\"\\n\\n\\n\\n%@\", self.test); }]; } {% endhighlight %} 总结 首先还是得说一下我这里只是演示了最最简单的block使用，因为作为一个iOS开发者不会block，那么有一大半的代码是看不懂的，在后面理解RAC的时候也会出现很大的问题。所以这里我只是做了简单的说明，至于在block里为什么不能调用self，自从segmentfault上有人问过之后我答错之后现在也算是理解了一部分了，但是牵扯到了内存回收的问题，我还需要一段时间来消化。消化完之后会继续写博客的。\n总之，block非常的有用，初期写block非常的难过，但是难过过了也就慢慢会喜欢上block的。\npost-credits scene 最近实在是忙的不可开交，一星期两场考试四个实验。还欠了人jobdeer.com一篇博客还没写，人送的书都没时间看。抽时间还要补起来。\n最近博客的更新频率也是大大降低…唉。都是泪。\n先写到这了。\n",
  "wordCount" : "355",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2015-05-29T00:00:00Z",
  "dateModified": "2015-05-29T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Me"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/2015-5-29-my-understand-about-block/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/index.xml" title="Feed">
                    <span>Feed</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="About">
                    <span>About</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Block 我所理解的回调
    </h1>
    <div class="post-meta"><span title='2015-05-29 00:00:00 +0000 UTC'>五月 29, 2015</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;Me

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#for-cm-and-plusub" aria-label="FOR CM AND PLUSUB">FOR CM AND PLUSUB</a></li>
                <li>
                    <a href="#%e5%ba%9f%e8%af%9d" aria-label="废话">废话</a></li>
                <li>
                    <a href="#%e6%a6%82%e8%bf%b0" aria-label="概述">概述</a></li>
                <li>
                    <a href="#_part1-block%e7%9a%84%e7%ae%80%e5%8d%95%e5%ae%9a%e4%b9%89_" aria-label="part1 block的简单定义">part1 block的简单定义</a></li>
                <li>
                    <a href="#_part2-%e4%bc%a0%e5%8f%82block_" aria-label="part2 传参block">part2 传参block</a></li>
                <li>
                    <a href="#_part3-%e7%82%b9%e5%87%bbbutton%e8%a7%a6%e5%8f%91block_" aria-label="part3 点击button触发block">part3 点击button触发block</a></li>
                <li>
                    <a href="#_part4-%e5%88%a9%e7%94%a8%e5%9b%9e%e8%b0%83%e5%88%86%e7%a6%bbafnetwork%e7%9a%84%e8%af%b7%e6%b1%82_" aria-label="part4 利用回调分离afnetwork的请求">part4 利用回调分离afnetwork的请求</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li>
                <li>
                    <a href="#post-credits-scene" aria-label="post-credits scene">post-credits scene</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="for-cm-and-plusub">FOR CM AND PLUSUB<a hidden class="anchor" aria-hidden="true" href="#for-cm-and-plusub">#</a></h2>
<h2 id="废话">废话<a hidden class="anchor" aria-hidden="true" href="#废话">#</a></h2>
<blockquote>
<p>开发iOS距离一年还有四个月。block的文章看了很多。也在项目中使用了，但是使用率很低，仅限于最最简单的界面传值。</p>
</blockquote>
<blockquote>
<p>我最近处于一个深度学习和补作业做实验的阶段(重点是补作业和做实验)，而且经历了两个项目现在对于OC的理解又更进了一步。于是抽时间把之前下载的关于block的视频又翻出来看了一下。有一些感受写出来，以便CM和PLUSUB以后的iOSer可以很快的学习到关于block的使用。以后这样的文章都会在标题加一个FOR CM AND PLUSUB。</p>
</blockquote>
<h2 id="概述">概述<a hidden class="anchor" aria-hidden="true" href="#概述">#</a></h2>
<blockquote>
<p>block就是闭包，可以用来回调。</p>
</blockquote>
<blockquote>
<p>再简单一点，指向函数的指针。</p>
</blockquote>
<blockquote>
<p>我现在只会简单的使用block，下午写了个demo利用block封装了afnetworking然后在另一个界面调用afnetworking的请求。当然不复杂。</p>
</blockquote>
<blockquote>
<p>上代码吧，不然再废话都解释不清楚什么是block。</p>
</blockquote>
<h2 id="_part1-block的简单定义_"><em>part1 block的简单定义</em><a hidden class="anchor" aria-hidden="true" href="#_part1-block的简单定义_">#</a></h2>
<p>我现在定义一个简单的block。
{% highlight objc %}
void (^myBlock)(NSString *str);//1
myBlock = ^(NSString *str)
{
NSLog(@&quot;&mdash;%@&quot;, str);//2
};
myBlock(@&ldquo;11111&rdquo;);//3
// Outputs:&mdash;11111
{% endhighlight %}
可以这么理解，我定义了一个返回值为void类型的block。void后面跟了一个函数，但是这个函数函数名是以^开头的，需要用括号包起来，参数也需要用括号包起来。参数可以是一个int类型，可以是一个NSString类型，还可以是一个函数！可以是多个参数还可以是一个函数。当然如果是int类型的block就需要return一个返回值了。</p>
<p>然后我们开始对这个void类型的函数进行定义。就是令它等于一个“^+参数”然后里面像定义一个函数一样就行了。
在调用这个block的时候就直接就myBlock加参数就可以了。</p>
<p>我们可以打断点来看一下整个block的执行顺序。我在代码后面加了标示。</p>
<p>执行顺序是1 3 2，可以看到myBlock没有按照程序执行的顺序来调用而是在调用之后执行了2的代码。这个例子可能不那么明显，但是可以开始初步理解回调。</p>
<h2 id="_part2-传参block_"><em>part2 传参block</em><a hidden class="anchor" aria-hidden="true" href="#_part2-传参block_">#</a></h2>
<p>下面把难度加大一点，我们把block当参数传。然后看一个block的例子。
首先来回顾一个c语言里伟大的typedef，我们开头会利用typedef定义一个block。如果不利用typedef定义一个block，那么函数传参的时候会写很多代码。一会我会详述。
{% highlight objc %}
#import &ldquo;ViewController.h&rdquo;
typedef void (^MyBlock)(NSString *str);//typedef定义一个block</p>
<p>@interface ViewController ()
@end</p>
<p>@implementation ViewController</p>
<ul>
<li>(void)viewDidLoad {
[super viewDidLoad];
MyBlock tblock = ^(NSString *str) {
NSLog(@&quot;&mdash;&ndash;%@&quot;, str);//1
};
[self testBlock:tblock];//2
}</li>
<li>(void)testBlock:(MyBlock)mBlock
//如果开始没有用typedef定义的话，此处的函数变为- (void)testBlock:(void(^)(NSString *str))myblock
//简单的说格式就是 “返回值 + (^) + 参数 + 名字”
{
mBlock(@&ldquo;1111&rdquo;);//3
}
// Outputs:&mdash;&ndash;1111
{% endhighlight %}</li>
</ul>
<p>在上面的代码中，我们写了一个testBlock的函数，将我们的tblock作为参数传到了testBlock函数里面，然后再testBlock里用mBlock调用了我们所写的MyBlock这个函数。</p>
<p>打断点看一下整体的运行流程，2 3 1。这里可以更加明显理解“回调”的含义。</p>
<h2 id="_part3-点击button触发block_"><em>part3 点击button触发block</em><a hidden class="anchor" aria-hidden="true" href="#_part3-点击button触发block_">#</a></h2>
<p>经历了上面两个part基本上应该对block有个简单的理解。下面再加一点难度，用按钮触发一个回调来改变按钮的颜色。</p>
<p>不多解释，直接上代码。
{% highlight objc %}
#import &ldquo;ViewController.h&rdquo;
typedef void (^MyBlock)(UIColor *color);
@interface ViewController ()
@property (nonatomic, strong) UIButton *testbtn;
@end</p>
<p>@implementation ViewController</p>
<ul>
<li>(void)viewDidLoad {
[super viewDidLoad];
self.testbtn = [UIButton buttonWithType:UIButtonTypeSystem];
self.testbtn.frame = CGRectMake(0, 0, 200, 40);
self.testbtn.backgroundColor = [UIColor greenColor];
[self.view addSubview:self.testbtn];
[self.testbtn addTarget:self action:@selector(testfunc) forControlEvents:UIControlEventTouchUpInside];
}</li>
<li>(void)testfunc
{
MyBlock myblock = ^(UIColor *color) {
self.testbtn.backgroundColor = color;
};
[self testBlock:myblock];
}</li>
<li>(void)testBlock:(MyBlock)myBlock
{
UIColor *color = [UIColor redColor];
myBlock(color);
}
{% endhighlight %}</li>
</ul>
<h2 id="_part4-利用回调分离afnetwork的请求_"><em>part4 利用回调分离afnetwork的请求</em><a hidden class="anchor" aria-hidden="true" href="#_part4-利用回调分离afnetwork的请求_">#</a></h2>
<p>直接上代码了。</p>
<p>TestNetworkViewController是afnetwork使用的地方。
TestViewController是我们需要调用网络请求的地方。
SearchModel是一个model，我用来解析数据的。
{% highlight objc %}
//  TestNetworkViewController.h
#import &lt;UIKit/UIKit.h&gt;
#import &ldquo;SearchModel.h&rdquo;
typedef void (^GetModel)(SearchModel *model);
@interface TestNetworkViewController : UIViewController</p>
<ul>
<li>(void)getUrl:(GetModel)getmodel;
@end</li>
</ul>
<p>//TestNetworkViewController.m
#import &ldquo;TestNetworkViewController.h&rdquo;
@interface TestNetworkViewController ()
@end
@implementation TestNetworkViewController</p>
<ul>
<li>(void)viewDidLoad {
[super viewDidLoad];
}</li>
</ul>
<ul>
<li>(void)getUrl:(GetModel)getmodel
{
AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
[manager GET:@&ldquo;http://xxx.xx.xxx.xx:xxxx/app/search_haosou&rdquo; parameters:@{@&ldquo;keyword&rdquo;:@&ldquo;android&rdquo;} success:^(AFHTTPRequestOperation *operation, id responseObject) {
NSLog(@&ldquo;JSON: %@&rdquo;, responseObject);
SearchModel *service = [MTLJSONAdapter modelOfClass:SearchModel.class fromJSONDictionary:responseObject error:nil];
getmodel(service);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
NSLog(@&ldquo;Error: %@&rdquo;, error);
}];
}
@end</li>
</ul>
<p>//  TestViewController.h
#import &lt;UIKit/UIKit.h&gt;
#import &ldquo;SearchModel.h&rdquo;
@interface TestViewController : UIViewController
@end</p>
<p>#import &ldquo;TestViewController.h&rdquo;
#import &ldquo;TestNetworkViewController.h&rdquo;
#import &ldquo;SearchModel.h&rdquo;
@interface TestViewController ()
@property (nonatomic, strong) SearchModel *test;
@end</p>
<p>@implementation TestViewController</p>
<ul>
<li>(void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view.
UIButton *testBtn = [UIButton buttonWithType:UIButtonTypeSystem];
[testBtn setTitle:@&ldquo;test&rdquo; forState:UIControlStateNormal];
[testBtn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];
testBtn.frame = CGRectMake(0, 100, 200, 40);
[testBtn addTarget:self action:@selector(getUrl) forControlEvents:UIControlEventTouchUpInside];
[self.view addSubview:testBtn];
self.view.backgroundColor = [UIColor whiteColor];
}</li>
<li>(void)getUrl
{
[TestNetworkViewController getUrl:^(SearchModel *model) {
self.test = model;
NSLog(@&quot;\n\n\n\n%@&quot;, self.test);
}];
}
{% endhighlight %}</li>
</ul>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<blockquote>
<p>首先还是得说一下我这里只是演示了最最简单的block使用，因为作为一个iOS开发者不会block，那么有一大半的代码是看不懂的，在后面理解RAC的时候也会出现很大的问题。所以这里我只是做了简单的说明，至于在block里为什么不能调用self，自从segmentfault上有人问过之后我答错之后现在也算是理解了一部分了，但是牵扯到了内存回收的问题，我还需要一段时间来消化。消化完之后会继续写博客的。</p>
</blockquote>
<blockquote>
<p>总之，block非常的有用，初期写block非常的难过，但是难过过了也就慢慢会喜欢上block的。</p>
</blockquote>
<h2 id="post-credits-scene">post-credits scene<a hidden class="anchor" aria-hidden="true" href="#post-credits-scene">#</a></h2>
<blockquote>
<p>最近实在是忙的不可开交，一星期两场考试四个实验。还欠了人jobdeer.com一篇博客还没写，人送的书都没时间看。抽时间还要补起来。</p>
</blockquote>
<blockquote>
<p>最近博客的更新频率也是大大降低&hellip;唉。都是泪。</p>
</blockquote>
<blockquote>
<p>先写到这了。</p>
</blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/2015-9-8-mac-aircrack/">
    <span class="title">« 上一页</span>
    <br>
    <span>Mac安装Aircrack-ng</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/somethingaboutwindows/">
    <span class="title">下一页 »</span>
    <br>
    <span>windows电脑的使用和优化杂谈</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://www.dididigu.com/">DiDi&rsquo;s Website</a></span> · 

    <span>
        tesths © 2024. All rights reserved.
        
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
